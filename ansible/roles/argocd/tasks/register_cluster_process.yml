# tasks/register_cluster_process.yml
---
# 1. Identify the Remote Master
- name: "Identify Bootstrap Node: {{ target_cluster_group }}"
  ansible.builtin.set_fact:
    remote_master: "{{ hostvars[groups[target_cluster_group][0]]['kubeadm_bootstrap_node'] }}"

- name: "Identify API URL: {{ target_cluster_group }}"
  ansible.builtin.set_fact:
    remote_api_url: "https://{{ target_cluster_group }}-api.example.com:6443"
    remote_api_ip: "{{ hostvars[remote_master]['ansible_host'] }}"

# 2. Execute on Remote Cluster (Create Access)
- name: "Create ArgoCD Manager ServiceAccount: {{ remote_master }}"
  ansible.builtin.shell: |
    set -o pipefail
    kubectl create sa argocd-manager -n kube-system --dry-run=client -o yaml | kubectl apply -f -
    kubectl create clusterrolebinding argocd-manager-role \
      --clusterrole=cluster-admin \
      --serviceaccount=kube-system:argocd-manager \
      --dry-run=client -o yaml | kubectl apply -f -
  args:
    executable: /bin/bash
  delegate_to: "{{ remote_master }}"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: sa_create
  changed_when: "'created' in sa_create.stdout"

- name: "Create Long-Lived Token Secret: {{ remote_master }}"
  ansible.builtin.shell: |
    set -o pipefail
    cat <<EOF | kubectl apply -f -
    apiVersion: v1
    kind: Secret
    metadata:
      name: argocd-manager-token
      namespace: kube-system
      annotations:
        kubernetes.io/service-account.name: argocd-manager
    type: kubernetes.io/service-account-token
    EOF
  args:
    executable: /bin/bash
  delegate_to: "{{ remote_master }}"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  changed_when: false

# NEW LOGIC: Get Raw JSON to preserve certificate formatting
- name: "Fetch Service Account Secret (JSON): {{ remote_master }}"
  ansible.builtin.command: >
    kubectl get secret argocd-manager-token -n kube-system -o json
  delegate_to: "{{ remote_master }}"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: remote_secret_json
  changed_when: false

- name: Parse Credentials from JSON
  ansible.builtin.set_fact:
    # Decode token so we can put the raw string in the JSON config
    remote_token: "{{ (remote_secret_json.stdout | from_json).data.token | b64decode }}"
    # Keep CA as Base64. Do NOT decode. The target secret needs it as Base64.
    remote_ca_b64: "{{ (remote_secret_json.stdout | from_json).data['ca.crt'] }}"

# 3. Ensure TLS Certificate SANs (The Fix)
- name: "Check API Server Cert SANs: {{ remote_master }}"
  ansible.builtin.shell: |
    openssl x509 -in /etc/kubernetes/pki/apiserver.crt -noout -text | grep "{{ target_cluster_group }}-api.example.com"
  delegate_to: "{{ remote_master }}"
  become: true
  register: cert_sans_check
  failed_when: false
  changed_when: false

- name: "Update API Server Cert with SANs: {{ remote_master }}"
  ansible.builtin.shell: |
    # Clean up old certs key to force regeneration (optional but safer for kubeadm phases)
    rm /etc/kubernetes/pki/apiserver.crt /etc/kubernetes/pki/apiserver.key

    # Kubeadm init phase to regenerate apiserver cert
    kubeadm init phase certs apiserver --apiserver-cert-extra-sans "{{ target_cluster_group }}-api.example.com"
  delegate_to: "{{ remote_master }}"
  become: true
  when: cert_sans_check.rc != 0

- name: "Restart API Server (Force Reload): {{ remote_master }}"
  ansible.builtin.shell: |
    crictl ps --name kube-apiserver -q | xargs -r crictl stop
    # Alternative: kubectl delete pod -n kube-system -l component=kube-apiserver --force
    # But crictl is more direct if kubectl is flaky during restart
  delegate_to: "{{ remote_master }}"
  become: true
  when: cert_sans_check.rc != 0

# 3. Execute on Local Management Cluster (Register)
- name: "Ensure DNS Resolution for Cluster: {{ target_cluster_group }}"
  ansible.builtin.lineinfile:
    path: /etc/hosts
    line: "{{ remote_api_ip }} {{ target_cluster_group }}-api.example.com"
    state: present
  become: true

- name: "Register Cluster in ArgoCD: {{ target_cluster_group }}"
  ansible.builtin.template:
    src: cluster-secret.yaml.j2
    dest: "/tmp/secret-{{ target_cluster_group }}.yaml"
    mode: "0600"

- name: "Apply Cluster Secret: {{ target_cluster_group }}"
  ansible.builtin.command: kubectl apply -f "/tmp/secret-{{ target_cluster_group }}.yaml"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: secret_apply
  changed_when: "'created' in secret_apply.stdout or 'configured' in secret_apply.stdout"

- name: "Cleanup Temp Secret: {{ target_cluster_group }}"
  ansible.builtin.file:
    path: "/tmp/secret-{{ target_cluster_group }}.yaml"
    state: absent
