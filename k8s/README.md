
# Kubernetes Operations Guide

This directory (`k8s/`) contains the complete declarative state for all applications and services running on the homelab's Kubernetes cluster. This document serves as the primary runbook for deploying, managing, and recovering the application platform.

The entire system is managed via **Kustomize**. All operations should be performed by modifying the YAML files in this directory and applying them from the root.

## Table of Contents
1.  [Prerequisites & Initial Setup](#1-prerequisites--initial-setup)
2.  [CRITICAL: Backing Up the Master Key](#2-critical-backing-up-the-master-key)
3.  [Day-to-Day Operations](#3-day-to-day-operations)
    -   [Applying Changes](#applying-changes)
    -   [Adding a New Application](#adding-a-new-application)
    -   [Managing Secrets](#managing-secrets)
4.  [Disaster Recovery Plan](#4-disaster-recovery-plan)

---

## 1. Prerequisites & Initial Setup

This procedure is for bootstrapping the Kubernetes cluster on a freshly provisioned VM (e.g., `megalo`).

### Step 1: Prepare the VM
*   Install all necessary tools (`docker`, `kind`, `kubectl`, `kubeseal`) by following the `docs/System_Setup.md` guide.
*   Configure the NFS mount at `/mnt/nfs/media-share` by following the `docs/Storage_Architecture.md` guide.

### Step 2: Clone the Repository
```bash
git clone <your-repo-url>
cd platform-stack/
```

### Step 3: Create the Kind Cluster
The `kind-config.yaml` is pre-configured to handle port mappings and NFS volume mounts.
```bash
kind create cluster --config k8s/kind-config.yaml
```

### Step 4: Perform the Two-Phase Bootstrap
The initial deployment must be done in two phases to avoid race conditions with Custom Resource Definitions (CRDs).

*   **Phase 1: Apply Core Infrastructure CRDs**
    This step installs the definitions for Traefik, Prometheus, and Sealed Secrets.
    ```bash
    # Apply Traefik CRDs
    kubectl apply -f k8s/traefik/01-crd.yaml

    # Apply Prometheus CRDs
    kubectl apply --server-side -k k8s/monitoring/manifests/setup/

    # Wait for CRDs to be registered by the API server
    echo "Waiting 30 seconds for CRDs to be established..."
    sleep 30
    ```

*   **Phase 2: Apply the Full Stack**
    This command deploys everything else. It is safe to run this command multiple times.
    ```bash
    kubectl apply -k k8s/
    ```

### Step 5: Verify the Deployment
Use `kubectl get pods -A` to watch all pods across all namespaces. It may take 10-15 minutes for all images to be pulled and all applications to become healthy (`Running`, `1/1`, `2/2`, etc.).

---

## 2. CRITICAL: Backing Up the Master Key

The entire secret management workflow relies on a single, vital component: the **master key**. This is the private key generated by the Sealed Secrets controller inside the cluster. It is the only key in the universe that can decrypt the `SealedSecret` files in this repository.

> **Warning:** This backup procedure should be performed once immediately after the initial cluster setup. Without this key, you will lose the ability to recover your secrets in a disaster or edit existing secrets.

### Procedure (One-Time Only)

1.  **Ensure you are connected** to your new Kubernetes cluster.

2.  **Run the following command.** It will find the secret containing the private key, extract its content as YAML, and save it to a file named `master.key` in your current directory.
    ```bash
    kubectl get secret -n kube-system -l sealedsecrets.bitnami.com/sealed-secrets-key -o yaml > master.key
    ```

3.  **Verify the file.** You will now have a `master.key` file in your directory. Its contents are the full YAML definition of the Kubernetes `Secret`.

### Securing Your Master Key

This `master.key` file is the most sensitive piece of your entire infrastructure. Anyone who has this file can decrypt all of your secrets.

*   **DO NOT** commit this file to your main `platform-stack` repository.
*   **MOVE** this file immediately to your designated secure private repository: **`https://github.com/sinhaaritro/homelab-kube-sealed-secret`**.
*   After you have committed and pushed the key to your private repository, **delete the `master.key` file** from your local `platform-stack` directory to prevent accidental commits.

This private repository is now your secure backup. You will only need to clone it when performing disaster recovery or editing an existing secret.

---

## 3. Day-to-Day Operations

### Applying Changes

This repository is the single source of truth. **Do not** use `kubectl edit` or `kubectl patch` to make manual changes. All changes must be made to the YAML files and applied with Kustomize.

From the root of the `platform-stack` repository, run:
```bash
kubectl apply -k k8s/
```
This single command will safely create, update, or delete resources to make the cluster's state match the configuration in this directory.

### Adding a New Application

Follow the established pattern:
1.  Create a new directory for the application (e.g., `k8s/new-app/`).
2.  Create the necessary manifest files inside (`namespace`, `pvc`, `deployment`, `service`, `ingressroute`, `kustomization.yaml`).
3.  Add the new directory (`- ./new-app`) to the `resources` list in the root `k8s/kustomization.yaml`.
4.  Add the new namespace to the `namespaces` argument in `k8s/traefik/03-daemonset.yaml`.
5.  Add a DNS rewrite for `new-app.localhost` in your AdGuard Home instance.
6.  Run `kubectl apply -k k8s/`.

### Managing Secrets

All secrets in this repository must be encrypted as `SealedSecret` objects. The **pre-commit hook** in this repository will automatically check for and reject any commits that contain an unencrypted `kind: Secret`.

#### Workflow 1: Creating a Brand New Secret

1.  **Create a Plain-Text `Secret` File:**
    Create a new file (e.g., `k8s/some-app/06-new-secret.yaml`) and define it as a standard `Secret`. In value of `API_KEY` needs to be in base64. Because decrypt will always give the value back in base64
    ```yaml
    apiVersion: v1
    kind: Secret
    metadata:
      name: my-new-secret
      namespace: some-app
    data:
      API_KEY: "supersecretvalue"
    ```

2.  **Encrypt the File In-Place:**
    Use `kubeseal` to encrypt the file, saving the output to a temporary file, and then replacing the original.
    ```bash
    # This encrypts the file and saves it as a SealedSecret
    # This replaces the original plain-text file with the encrypted version
    # Replace <path-to-your-file>
    kubeseal --format=yaml < <path-to-your-file> > temp.yaml && mv temp.yaml <path-to-your-file>
    ```
    The file <path-to-your-file> now contains a `kind: SealedSecret` and is safe to commit.

3.  **Add the file** to the appropriate `kustomization.yaml` and run `kubectl apply -k k8s/`.

#### Workflow 2: Editing an Existing Secret

**Prerequisite:** You must have cloned your private key repository and have the `master.key` file available locally.

1.  **Identify the File:**
    Choose the `SealedSecret` file you wish to edit (e.g., `k8s/homepage/05-homepage-sealed-secret.yaml`).

2.  **Decrypt the File In-Place:**
    This command decrypts the `SealedSecret` and **overwrites the original file** with the plain-text `Secret` content.
    ```bash
    # Replace <path-to-your-master.key> and <path-to-your-file>
    kubeseal --recovery-unseal --recovery-private-key <path-to-your-master.key> -o yaml < <path-to-your-file> > temp.yaml && mv temp.yaml <path-to-your-file>
    ```

3.  **Make Your Edits:**
    Open the now plain-text file in your editor, make changes, and save. The ENV values are in **base64**.

4.  **Re-Encrypt the File In-Place:**
    This command reads your edited, plain-text file and **overwrites it again** with the new `SealedSecret` content.
    ```bash
    # Replace <path-to-your-file>
    kubeseal --format=yaml < <path-to-your-file> > temp.yaml && mv temp.yaml <path-to-your-file>
    ```
    The file is now an encrypted `SealedSecret` again and is safe to commit and apply.

---

## 4. Disaster Recovery Plan

This plan covers the scenario where the **entire Kubernetes cluster and its underlying VM have been lost**, but the Proxmox host, the NFS share, and this Git repository are still intact.

### Procedure

1.  **Provision a New Kube VM:**
    *   Create a new VM and follow the `docs/System_Setup.md` guide to install all required tools.
    *   Configure the NFS mount.

2.  **Clone the Repositories:**
    *   `git clone https://github.com/your-org/platform-stack.git`
    *   `git clone https://github.com/sinhaaritro/homelab-kube-sealed-secret.git`

3.  **Create the Kind Cluster:**
    ```bash
    cd platform-stack/
    kind create cluster --config k8s/kind-config.yaml
    ```

4.  **Restore the Sealed Secrets Private Key (CRITICAL STEP):**
    The new Sealed Secrets controller will have generated a keypair that cannot decrypt your secrets. We must overwrite it with the backed-up key.
    ```bash
    # The master.key file is in the cloned private repository
    # This command will delete the new secret and replace it with your backed-up one.
    kubectl replace --force -f ../homelab-kube-sealed-secret/master.key
    ```

5.  **Restart the Controller:**
    To force the controller to load the restored key, restart its pod.
    ```bash
    kubectl rollout restart deployment sealed-secrets-controller -n kube-system
    ```

6.  **Perform the Two-Phase Bootstrap:**
    Now that the cluster can decrypt your secrets, proceed with the standard initial deployment as described in [Section 1](#1-prerequisites--initial-setup).
    *   Apply the CRDs.
    *   Wait 30 seconds.
    *   Apply the full stack with `kubectl apply -k k8s/`.

Your entire application stack, including all secrets, will be restored to its exact previous state.